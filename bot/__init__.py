from telethon import events,functions,errors
from telethon.sync import TelegramClient
from telethon.sessions import StringSession
from config import Config
import asyncio
import threading
import requests
import re

def cronjob():
    threading.Timer(60*5, cronjob).start()
    requests.get(Config.DOMAIN)
    
cronjob()

client = TelegramClient(
            StringSession(),
            Config.API_ID,
            Config.API_HASH,
            # proxy=("socks5","127.0.0.1",9050)
            ).start(bot_token=Config.TOKEN)

username_bot = client.get_me().username

def get_file_name(message):
    if message.file.name:
        return message.file.name.replace(" ","-")
    ext = message.file.ext or ""
    return f"file{ext}"

@client.on(events.NewMessage)
async def download(event):
    if (pv := event.is_private) or event.is_group :
        if pv:
            try:
                await event.client(functions.channels.GetParticipantRequest(
                    channel = Config.CHANNEL_USERNAME,
                    participant = event.sender_id
                    ))
            except errors.UserNotParticipantError:
                await event.reply(f"Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø²ÛŒØ± Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯ Ø³Ù¾Ø³ ÙØ§ÛŒÙ„ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ù†Ù…Ø§ÛŒÛŒØ¯.â†™ï¸\n\n@{Config.CHANNEL_USERNAME}\n\nâ­•ï¸Ø¨Ø¹Ø¯ Ø§Ø² Ø¹Ø¶Ùˆ Ø´Ø¯Ù† /start Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.")
                return
        
        if event.file :
            if not pv :
                if not event.file.size > 10_000_000:
                    return 
            sender = await event.get_sender()
            msg = await event.client.send_file(
                Config.CHANNEL,
                file=event.message.media,
                caption=f"@{sender.username}|[{event.chat_id}](tg://user?id={event.sender_id})/{event.message.id}")
            id_hex = hex(msg.id)[2:]
            id = f"{id_hex}/{get_file_name(msg)}"
            bot_url = f"t.me/{username_bot}?start={id_hex}"
            await event.reply(f"âš¡ Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú© Ú¯Ø°Ø§Ø±ÛŒ ÙØ§ÛŒÙ„ Ø´Ù…Ø§ ğŸ‘‡: \nğŸ“ : {bot_url}")
            return

        elif id_msg := re.search("/start (.*)", event.raw_text ):
            if id_hex := id_msg.group(1) :
                try:
                    id = int(id_hex,16)
                except ValueError:
                    return
                msg = await event.client.get_messages(Config.CHANNEL,ids=id)
                if not msg or not msg.file :
                    return await event.reply("404! File Not Found")
                if regex := re.search(r"(\d*)/(\d*)",msg.message):
                    if user_id := int(regex.group(1)) :
                        msg_id = int(regex.group(2))
                        file = await event.client.get_messages(user_id,ids=msg_id)
                        if not file or not file.file :
                            return await event.reply("404! File Not Found")
                        forward = await file.forward_to(event.chat_id)
                        id_name = f"{id_hex}/{get_file_name(msg)}"
                        bot_url = f"t.me/{username_bot}?start={id_hex}"
                        forward_reply = await forward.reply(f"ÙØ§ÛŒÙ„ Ø¨Ø¹Ø¯ Ø§Ø² 21 Ø«Ø§Ù†ÛŒÙ‡ Ø¯ÛŒÚ¯Ø± Ø­Ø°Ù Ù…ÛŒØ´ÙˆØ¯ ğŸ””")
                        await asyncio.sleep(12)
                        await forward_reply.edit(f"ğŸ”” ÙØ§ÛŒÙ„ Ø¨Ø¹Ø¯ Ø§Ø² 9 Ø«Ø§Ù†ÛŒÙ‡ Ø¯ÛŒÚ¯Ø± Ø­Ø°Ù Ù…ÛŒØ´ÙˆØ¯.")
                        await asyncio.sleep(10)
                        await forward.delete()
                        await forward_reply.edit(f"âœ… Ø¯Ø±ÛŒØ§ÙØª Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙØ§ÛŒÙ„ ğŸ‘‡/n ğŸ¤– : {bot_url}",link_preview=True)
                return
        if pv:
            await event.reply("ğŸ‘‹ Ø³Ù„Ø§Ù… ØŒ Ù…Ù† Ø±Ø¨Ø§Øª Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„ Ù‡Ø§ÛŒ Ú©Ø§Ù†Ø§Ù„ Ø³Ø±ÛŒØ²Ù¾Ù„Ø§Ø³ Ù‡Ø³ØªÙ… /n Ø¬Ù‡Øª Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„ Ù„ÛŒÙ†Ú© Ø¯Ø±Ø¬ Ø´Ø¯Ù‡ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø±Ø§ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ Ø¨Ù‡ Ø±Ø¨Ø§Øª Ù‡Ø¯Ø§ÛŒØª Ù…ÛŒØ´ÙˆØ¯ Ø¨Ø¹Ø¯ start Ø±Ø§ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ØŒ ÙØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒØªØ§Ù† Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒØ´ÙˆØ¯.â¦â¤ï¸â© ")
        

    elif event.is_channel:
        if event.chat_id == Config.CHANNEL:
            if event.reply_to:
                msg = await event.get_reply_message()
                if regex := re.search(r"(\d*)/(\d*)",msg.message):
                    if user_id := int(regex.group(1)) :
                        msg_id = int(regex.group(2))
                        if await event.client.send_message(entity=user_id, message=event.message, reply_to=msg_id):
                            await event.client.edit_message(event.chat_id,event.id,f"{event.message.message}\n sended")
                        
                        
                    
client.run_until_disconnected()
